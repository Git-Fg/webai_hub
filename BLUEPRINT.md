# **Blueprint : Hub d'IA Hybride (Mobile)**

**Document V1.1 - IMPLEMENT√â** ‚úÖ

## **1\. Vision & Principes Fondamentaux**

Ce document d√©finit l'architecture et les logiques d'une application mobile con√ßue pour centraliser l'acc√®s aux interfaces utilisateur Web (WebUI) des services d'IA. L'objectif est de fournir un "Hub" centralis√© qui assiste l'utilisateur en automatisant les t√¢ches r√©p√©titives (envoi de prompts, extraction de r√©ponses) tout en conservant la transparence et le contr√¥le manuel.

Ce blueprint s'inspire fortement du projet open-source de r√©f√©rence **"Code Web Chat" (CWC)**, une extension pour IDE qui connecte un √©diteur de code √† des chatbots Web. Nous adoptons sa philosophie et ses logiques d'interaction DOM (Document Object Model).

### **1.1. Philosophie (L'Esprit CWC)**

* **Principe 1 : Assister, ne pas cacher.** L'application est un "assistant" ou "connecteur", et non un "bot" automatis√©. L'objectif est de reproduire l'action d'un "copier-coller" intelligent (injection de prompt, extraction de r√©ponse) et non de masquer l'interface web du fournisseur de services. En n'automatisant que le d√©marrage de nouvelles conversations, nous adoptons la philosophie de CWC qui vise √† respecter les Conditions d'Utilisation (TOS) des diff√©rents services, qui interdisent souvent le "scraping" automatis√©.

### **1.2. Transparence Totale (Le "Marionnettiste")**

* **Principe 2 : L'utilisateur voit toujours ce que fait l'application.** Toute automatisation (injection de prompt, clic de bouton) s'ex√©cute de mani√®re visible, par-dessus la WebView du fournisseur. Cette approche "marionnettiste" permet √† l'utilisateur de suivre le processus, de renforcer sa confiance et de comprendre ce qui se passe, au lieu d'interagir avec une "bo√Æte noire" opaque.

### **1.3. Robustesse (Conception Anti-Fragile)**

* **Principe 3 : L'√©chec d'une automatisation n'est pas fatal.** Le cas d'√©chec le plus courant (un CAPTCHA, une demande de connexion, ou un changement de s√©lecteur CSS) est trait√© comme un *workflow nominal*. L'application est con√ßue pour d√©tecter cet √©chec, notifier l'utilisateur, et lui **rendre le contr√¥le manuel** sur la WebView. L'utilisateur peut alors r√©soudre le probl√®me (ex: se connecter) et reprendre le processus. Cela rend l'application fondamentalement plus fiable qu'une solution 100% automatis√©e.

### **1.4. Confidentialit√© (Local-First)**

* **Principe 4 : Adh√©rer √† la philosophie "Privacy focused" de CWC.** L'application fonctionne √† 100% sur l'appareil local ("operates 100% on your local machine"). Aucune conversation, ni du Hub, ni des WebViews, n'est envoy√©e ou stock√©e sur un serveur tiers appartenant √† l'application. Tout reste sur l'appareil, sous le contr√¥le de l'utilisateur.

## **2\. Architecture de l'Application (Le "Hub Hybride")**

### **2.1. Structure Principale**

L'application est structur√©e autour d'une interface √† 5 onglets persistants (ex: une TabBarView). Cette structure est con√ßue comme un MVP (Minimum Viable Product) et est extensible pour ajouter de futurs providers sans modifier l'architecture centrale.

* **Plateforme Cible :** Mobile (iOS et Android).

### **2.2. Onglet 1 : "Hub" (Natif)**

* **UI :** Une interface de chat 100% native.  
* **Composants :**  
  * **Liste des conversations :** Affiche les bulles de chat (prompts utilisateur et r√©ponses valid√©es).  
  * **Champ de saisie de texte :** Zone de saisie unique pour l'envoi de prompts.  
  * **S√©lecteur de "Provider" :** Un menu d√©roulant (ou similaire) pour choisir le service actif (AI Studio, Qwen, Z-ai, Kimi). Ce s√©lecteur doit √™tre li√© √† l'√©tat de connexion (voir 3.2) et griser les options non "Pr√™tes".  
  * **Bouton "Options" (‚öôÔ∏è) :** Un bouton contextuel qui, une fois cliqu√©, affiche les configurations sp√©cifiques au provider actuellement s√©lectionn√© (voir 5.1).  
  * **Boutons "Contexte" (üìé, üìã) :** Ic√¥nes permettant d'ajouter du contexte au prompt (presse-papiers ou s√©lection de fichiers).  
* **√âtat :** Affiche l'historique de la conversation native (stock√© localement). Affiche un indicateur d'√©tat pour chaque provider (voir Section 3.2).

### **2.3. Onglets 2-5 : "Providers" (WebView)**

* **UI :** Une WebView visible et unique par onglet.  
* **Persistance :** Les sessions WebView (cookies, stockage local) **doivent √™tre persistantes**. L'utilisateur ne doit se connecter qu'une seule fois par service. Les WebView ne sont pas recharg√©es lors du changement d'onglet ; elles restent "live" en arri√®re-plan pour maintenir l'√©tat et la connexion.  
* **Onglets (MVP) :**  
  * **Tab 2: "AI Studio"** (URL: https://aistudio.google.com/prompts/new\_chat)  
  * **Tab 3: "Qwen"** (URL: https://chat.qwen.ai/)  
  * **Tab 4: "Z-ai"** (URL: https://chat.z.ai/)  
  * **Tab 5: "Kimi"** (URL: https://www.kimi.com/)

### **2.4. L'Overlay "Compagnon" (Natif)**

* **UI :** Un composant d'interface natif (ex: un bandeau en bas ou un bouton flottant) qui est superpos√© *uniquement* sur les onglets WebView (2-5) et *seulement* pendant une automatisation active (Phases 1-3).  
* **R√¥le :** C'est le "pont de contr√¥le" natif qui g√®re le cycle de vie de l'automatisation.  
* **Composants de l'UI :**  
  1. Indicateur de statut (texte, ex: G√©n√©ration en cours...).  
  2. Bouton \[ ‚úÖ Valider et envoyer au Hub \].  
  3. Bouton \[ ‚ùå Annuler \].

## **3\. Exp√©rience Utilisateur & Gestion de l'√âtat**

### **3.1. Flux de Premier Lancement (Onboarding)**

* L'application s'ouvre sur l'onglet "Hub", qui affiche un √©cran de bienvenue ou un "√©tat vide".  
* L'interface guide (visuellement ou textuellement) l'utilisateur pour qu'il visite **manuellement** chaque onglet WebView (2-5) afin de s'y **connecter**.  
* **Exemple de guide :** Le Hub pourrait afficher un guide "Pour commencer" en 3 √©tapes : "1. Allez sur l'onglet 'Kimi', 2\. Connectez-vous √† votre compte Kimi, 3\. Revenez ici pour envoyer votre premier prompt."

### **3.2. Gestion de l'√âtat de Connexion**

* Le "Hub" (Tab 1\) doit refl√©ter l'√©tat de connexion de chaque service (ex: "Kimi: ‚úÖ Pr√™t", "Qwen: ‚ùå Connexion requise").  
* La s√©lection d'un provider dans le s√©lecteur du Hub ne doit √™tre activ√©e que pour les services "Pr√™ts".  
* **Logique de V√©rification de l'√âtat (Automation.checkStatus()):**  
  * Cette fonction doit √™tre appel√©e au d√©marrage de l'application pour chaque provider et chaque fois que l'utilisateur s√©lectionne un onglet WebView (pour rafra√Æchir l'√©tat).  
  * Elle injecte un script JS minimal et non-intrusif dans la WebView cible pour d√©terminer son √©tat.  
  * **Succ√®s (Pr√™t ‚úÖ) :** Le script trouve le s√©lecteur de la zone de saisie de prompt (ex: textarea, voir Section 8). Il appelle Bridge.onStatusResult({ status: 'ready' }).  
  * **√âchec (Connexion ‚ùå) :** Le script ne trouve pas la zone de saisie, mais trouve un s√©lecteur de page de login (ex: input\[type="password"\] ou un h1 contenant "Sign In"). Il appelle Bridge.onStatusResult({ status: 'login' }).

## **4\. Workflow "Assister & Valider" (Le C≈ìur Dynamique)**

C'est le flux principal d'interaction, combinant automatisation et contr√¥le manuel.

### **4.1. Phase 1 : L'Envoi (Assist√©)**

1. **Utilisateur :** Sur l'onglet **"Hub"**, s√©lectionne "Kimi", configure les "Options" (‚öôÔ∏è), ajoute du "Contexte" (ex: un fichier) et envoie le prompt.  
2. **App (Action) :** L'application formate le prompt en utilisant la structure d√©finie en Section 5.3.  
3. **Hub (UI) :** Affiche une bulle de chat \[Envoi vers Kimi...\].  
4. **App (Action) :** Bascule **automatiquement** l'utilisateur vers l'onglet **"Kimi" (Tab 5\)**.  
5. **Overlay (UI) :** L'overlay "Compagnon" appara√Æt sur Tab 5, affichant \[Automatisation en cours...\] (Bouton "Annuler" visible).  
6. **App (Action) :** Ex√©cute le script Automation.start(promptFormat√©, options) dans la WebView Kimi.

### **4.2. Phase 2 : L'Observation (L'Attente)**

1. JS (Action) : Le script Automation.start s'ex√©cute dans la WebView :  
   a. Attend que la page soit pr√™te (logique wait\_until\_ready, voir Section 6). Doit inclure un timeout pour d√©clencher onInjectionFailed si la page ne charge jamais.  
   b. Applique les configurations (logique set\_options / set\_model CWC, si options fournies, voir Section 5.1).  
   c. Injecte le promptFormat√© dans le textarea et simule le clic sur le bouton d'envoi (logique enter\_message\_and\_send).  
2. **JS (Observation) :** Un MutationObserver (logique observe\_for\_responses CWC) surveille le DOM. Il s'attache au conteneur de chat (subtree: true, childList: true) et surveille √©galement les attributs du bouton "Stop" (certains frameworks le d√©sactivent via disabled au lieu de le supprimer).  
3. **JS (D√©tection) :** L'observateur attend que la g√©n√©ration de la r√©ponse soit termin√©e (en se basant sur la *disparition* du s√©lecteur is\_generating de Kimi, voir Section 8).  
4. **JS (Callback) :** Le script envoie l'√©v√©nement Bridge.onGenerationComplete() √† la couche native.

### **4.3. Phase 3 : Le Raffinage (Contr√¥le Manuel)**

1. **App (R√©action) :** L'application native re√ßoit Bridge.onGenerationComplete().  
2. **Overlay (UI) :** L'overlay "Compagnon" change son √©tat : \[Pr√™t pour raffinage\] et affiche le bouton \[ ‚úÖ Valider et envoyer au Hub \].  
3. **Utilisateur (Action) :** L'utilisateur est maintenant libre. Il peut interagir manuellement avec la WebView Kimi (poser des questions de suivi, "raccourcis ce texte", etc.) autant de fois qu'il le souhaite. Il peut utiliser les fonctionnalit√©s natives du provider (ex: r√©g√©n√©ration, suggestions de suivi). Le bouton "Valider" attend.

### **4.4. Phase 4 : La Validation (L'Extraction)**

1. **Utilisateur (Action) :** Une fois satisfait de la r√©ponse affich√©e dans la WebView, il clique sur le bouton natif \[ ‚úÖ Valider et envoyer au Hub \].  
2. **App (Action) :** Ex√©cute le script Extraction.getFinalResponse() dans la WebView.  
3. **JS (Action) :** Le script localise la **derni√®re bulle de r√©ponse de l'assistant** (voir Section 8.3 pour la logique pr√©cise), en extrait le contenu (HTML/texte), et envoie le r√©sultat via Bridge.onExtractionResult(htmlContent).  
4. **App (R√©action) :** L'application native re√ßoit le contenu, bascule **automatiquement** l'utilisateur vers l'onglet **"Hub" (Tab 1\)**, et remplace le message \[Envoi vers Kimi...\] par la r√©ponse finale et valid√©e.

## **5\. Gestion du Contexte & Formatage des Prompts**

L'intelligence de l'application r√©side dans le formatage des prompts, directement inspir√© de CWC.

### **5.1. Logique de Configuration (via "Options" ‚öôÔ∏è)**

* Le bouton "Options" (‚öôÔ∏è) dans le Hub doit afficher les configurations disponibles pour le provider s√©lectionn√©.  
* **Exemple :** Si l'utilisateur choisit "Gemini" (futur provider) et l'option "Mod√®le 1.5 Pro", le script Automation.start doit d'abord simuler les clics (bas√© sur la logique set\_model de CWC) pour ouvrir le s√©lecteur de mod√®le et choisir "1.5 Pro", *avant* d'injecter le prompt.

### **5.2. Types de Contexte (MVP V1.0)**

* Pour la version 1.0, l'ajout de contexte (via les boutons "Contexte" üìé) est limit√© aux **fichiers texte** (ex: .txt, .md, .js, .py, .html) et au **contenu du presse-papiers**.  
* Les fichiers binaires (images, PDF) ne sont **pas** support√©s dans ce flux, car leur gestion (upload, drag-and-drop) est complexe et sp√©cifique √† chaque provider. L'utilisateur peut cependant les utiliser manuellement dans les onglets WebView.

### **5.3. Formatage du Prompt (Structure CWC)**

* Le promptFormat√© inject√© (Phase 1\) doit suivre la structure CWC pour une pr√©cision maximale. La **r√©p√©tition** du prompt est une technique de "prompt engineering" CWC critique pour √©viter que l'IA "n'oublie" l'instruction originale apr√®s un long contexte.  
  \[PROMPT UTILISATEUR\]  
  \<system\>  
  \[INSTRUCTIONS SYST√àME (ex: "R√©ponds en fran√ßais")\]  
  \</system\>

  \[CONTEXTE FORMAT√â (voir 5.4)\]

  \[PROMPT UTILISATEUR (R√âP√âT√â)\]  
  \<system\>  
  \[INSTRUCTIONS SYST√àME (R√âP√âT√âES)\]  
  \</system\>

### **5.4. Formatage des Fichiers (Contexte)**

* Lorsque l'utilisateur ajoute du contexte, il doit √™tre format√© en utilisant les balises XML de CWC. L'utilisation de \<\!\[CDATA\[...\]\]\> est essentielle pour que le contenu du fichier (qui peut contenir du XML/HTML) n'invalide pas le formatage XML du prompt lui-m√™me.  
  \<files\>  
    \<file path="nom\_du\_fichier.txt"\>  
    \<\!\[CDATA\[  
    ...Contenu du fichier ou du presse-papiers...  
    \]\]\>  
    \</file\>  
  \</files\>

## **6\. Logiques d'Interaction DOM (Le Moteur JavaScript)**

Le pont JS inject√© (ex: window.HubAutomation) doit impl√©menter les logiques suivantes, bas√©es sur les scripts CWC :

* **wait\_until\_ready :** Avant l'injection (Phase 1), un script JS doit s'assurer que la page est pr√™te (ex: que le textarea est pr√©sent, voir Section 8). Doit inclure un timeout (ex: 10 secondes) pour d√©clencher Bridge.onInjectionFailed si le s√©lecteur n'est jamais trouv√©.  
* **set\_options / set\_model :** Si des options sont fournies (Phase 1), le script simule les clics n√©cessaires pour configurer l'interface web (ex: changer de mod√®le).  
* **enter\_message\_and\_send :** La logique d'injection (Phase 1\) doit trouver le textarea (ou √©quivalent), y ins√©rer le promptFormat√©, et simuler un clic sur le bouton d'envoi.  
* **observe\_for\_responses :** La logique d'observation (Phase 2\) doit utiliser un MutationObserver pour surveiller le DOM. La cl√© est la fonction is\_generating qui v√©rifie la *pr√©sence* d'un s√©lecteur "Stop" (voir Section 8). La fin de la g√©n√©ration est d√©tect√©e lorsque ce s√©lecteur *dispara√Æt* ou devient *d√©sactiv√©*.  
* **get\_final\_assistant\_response :** La logique d'extraction (Phase 4\) doit trouver *tous* les √©l√©ments correspondant au assistant\_response\_selector (voir Section 8), prendre le **dernier** de la liste, et en extraire le contenu.

## **7\. Contrat d'API (Pont Natif \<-\> JavaScript)**

Pour assurer une communication propre, un contrat d'API strict doit √™tre respect√©. La communication Natif \-\> JS se fait via runJavaScript(). La communication JS \-\> Natif se fait via les JavaScriptChannel.

### **7.1. Canaux de Communication**

* Un JavaScriptChannel unique doit √™tre d√©fini par provider pour la communication JS vers Natif.  
* Exemples : AIStudioBridge, QwenBridge, ZaiBridge, KimiBridge.

### **7.2. Fonctions JS (Appel√©es par le Natif)**

Toutes les fonctions sont pr√©fix√©es (ex: window.HubAutomation) pour √©viter les conflits.

* window.HubAutomation.start(promptFormat√©, optionsJSON)  
  * **Description :** D√©clenche les Phases 1 (Injection) et 2 (Observation).  
  * **optionsJSON :** Un objet JSON contenant les configurations (ex: { "model": "opus" }).  
* window.HubAutomation.cancel()  
  * **Description :** Annule toute MutationObserver ou boucle d'attente JS en cours.  
* window.HubAutomation.Extraction.getFinalResponse()  
  * **Description :** D√©clenche la Phase 4 (Validation).  
* window.HubAutomation.checkStatus()  
  * **Description :** D√©clenche la v√©rification d'√©tat non-intrusive (voir Section 3.2).

### **7.3. √âv√©nements JS (Envoy√©s au Natif via le Canal)**

Les messages doivent √™tre une **cha√Æne JSON s√©rialis√©e** unique contenant un objet event et un payload.

* \[BridgeName\].postMessage(JSON.stringify({ event: 'onStatusResult', payload: { status: 'ready' | 'login' } }))  
* \[BridgeName\].postMessage(JSON.stringify({ event: 'onInjectionFailed', payload: { error: 'Raison de l'√©chec (ex: S√©lecteur non trouv√©)' } }))  
* \[BridgeName\].postMessage(JSON.stringify({ event: 'onGenerationComplete' }))  
* \[BridgeName\].postMessage(JSON.stringify({ event: 'onExtractionResult', payload: { content: '...html ou texte extrait...' } }))

## **8\. Dictionnaire des S√©lecteurs (Base CWC)**

L'impl√©mentation des logiques JS (Section 6\) d√©pend de ces s√©lecteurs. **Ces s√©lecteurs sont le point le plus fragile du syst√®me** (voir Section 10.3 pour la strat√©gie de maintenance).

*Note : Les s√©lecteurs CWC originaux (ex: SVG path\[d^="M..."\]) sont tr√®s fragiles et souvent bas√©s sur des chemins SVG qui peuvent changer. Le tableau ci-dessous utilise des s√©lecteurs de classe ou d'attributs plus g√©n√©riques, inspir√©s de CWC, qui devront √™tre valid√©s et maintenus.*

### **8.1. Tableau des S√©lecteurs (MVP)**

| Provider | URL de base | wait\_until\_ready (Attente) | enter\_message\_and\_send (Clic) | is\_generating (G√©n√©ration) | assistant\_response\_selector (Extraction) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **AI Studio** | ...aistudio.google.com... | input-area | send-button\[variant="primary"\] | mat-icon\[data-mat-icon-name="stop"\] | response-container |
| **Qwen** | ...chat.qwen.ai/ | textarea | button\[class\*="Button\_button\_"\]\[class\*="Button\_primary\_"\] | button\[class\*\*="Button\_danger\_"\] | div\[class\*="Message\_messageItem\_"\] |
| **Z-ai** | ...chat.z.ai/ | textarea | button\[class\*="ChatInput\_sendButton\_"\] | button\[aria-label="Stop generating"\] | div\[class\*="ConversationItem\_conversationItem\_"\] |
| **Kimi** | ...www.kimi.com/ | textarea\[placeholder\*="Kimi"\] | button \> svg\[class\*="Icon\_icon\_"\] | div\[class\*="ChatInterlude\_stopBtn\_"\] | div\[data-message-role="assistant"\] |

### **8.2. Logique d'Extraction (Pr√©cision Phase 4\)**

* Pour garantir que la r√©ponse correcte est extraite (et non le prompt de l'utilisateur ou une r√©ponse pr√©c√©dente), le script Extraction.getFinalResponse() **doit** :  
  1. Utiliser le assistant\_response\_selector du tableau ci-dessus (ex: div\[data-message-role="assistant"\] pour Kimi).  
  2. Ex√©cuter document.querySelectorAll(...) avec ce s√©lecteur.  
  3. Prendre le **dernier** √©l√©ment (Node) de la NodeList r√©sultante.  
  4. S'assurer que cet √©l√©ment existe.  
  5. Extraire son contenu (innerHTML pour conserver le formatage du code, ou innerText pour le texte brut).

## **9\. Gestion des Erreurs & Cycle de Vie**

### **9.1. Cycle de Vie de l'Overlay "Compagnon"**

* **√âtat 1 (Inactif) :** Cach√©.  
* **√âtat 2 (En cours) :** Visible pendant les Phases 1 & 2\. Affiche \[Automatisation en cours...\]. Seul le bouton "Annuler" est visible/actif.  
* **√âtat 3 (En attente) :** Visible pendant la Phase 3\. Affiche \[Pr√™t pour raffinage\]. Les boutons "Valider" et "Annuler" sont visibles/actifs.

### **9.2. Gestion des Erreurs (Robustesse)**

* **Cas : √âchec d'injection (Login/CAPTCHA)**  
  1. Automation.start √©choue (ex: textarea non trouv√©).  
  2. Le script JS envoie Bridge.onInjectionFailed("S√©lecteur 'textarea' non trouv√©").  
  3. L'application native **ne retourne pas** au Hub.  
  4. L'overlay "Compagnon" (√âtat 2\) affiche l'erreur : \[ ‚ö†Ô∏è Automatisation √©chou√©e. Veuillez vous connecter ou r√©soudre le CAPTCHA manuellement. \] puis se cache (√âtat 1).  
  5. Le message dans le Hub (Tab 1\) est mis √† jour de \[Envoi...\] √† \[√âchec de l'envoi\].  
* **Cas : Annulation Utilisateur (Clic Bouton)**  
  1. L'utilisateur clique sur "Annuler" (pendant l'√âtat 2 ou 3).  
  2. L'application ex√©cute Automation.cancel() (pour arr√™ter tout MutationObserver ou boucle JS).  
  3. L'overlay "Compagnon" est cach√© (√âtat 1).  
  4. L'application **ne retourne pas** au Hub.  
  5. Le message dans le Hub est mis √† jour : \[Annul√© par l'utilisateur\].  
* **Cas : Annulation (Navigation Manuelle)**  
  * Si l'utilisateur quitte manuellement l'onglet WebView (ex: Kimi) pendant que l'automatisation est en √âtat 2 ou 3, cela doit √™tre trait√© comme une "Annulation" (voir 9.2, Cas : Annulation Utilisateur).

## **10\. Persistance, S√©curit√© & Maintenance**

### **10.1. Persistance des Donn√©es** ‚úÖ **IMPL√âMENT√â**

* **Hub (Natif) :** L'historique de l'onglet "Hub" (Tab 1\) est stock√© dans une **base de donn√©es locale** sur l'appareil (ex: SQLite). Aucune synchronisation ou envoi de cet historique √† un serveur externe ne doit avoir lieu.
* **WebView (Web) :** Les WebView (Tabs 2-5) doivent avoir la **persistance des cookies et des sessions** activ√©e pour que l'utilisateur n'ait pas √† se reconnecter √† chaque utilisation.

### **10.2. S√©curit√© & Confidentialit√©** ‚úÖ **IMPL√âMENT√â**

* **Isolation :** La couche native (le "Hub") **n'a pas** le droit de lire les cookies, le localStorage, ou les identifiants des WebView. L'interaction est *strictement* limit√©e au Contrat d'API (Section 7).
* **Cl√©s API (Fonctionnalit√© Future) :** Si, √† l'avenir, des API directes sont ajout√©es (similaires aux "API Tools" de CWC), leurs cl√©s *doivent* √™tre stock√©es dans le **stockage s√©curis√© et chiffr√©** de l'appareil (Keychain/Keystore) et jamais en clair.
* **Aucune Collecte :** Le blueprint affirme qu'aucune donn√©e de conversation n'est collect√©e par l'application elle-m√™me.

### **10.3. Strat√©gie de Maintenance des S√©lecteurs** ‚úÖ **IMPL√âMENT√â**

* **Probl√®me :** Les s√©lecteurs DOM (Section 8\) sont le point de d√©faillance le plus probable. Les fournisseurs de services les modifient fr√©quemment.
* **Strat√©gie :** Les s√©lecteurs ne seront **pas cod√©s en dur** dans l'application.
  1. Au premier d√©marrage, l'application r√©cup√©rera un fichier de configuration JSON (le "Dictionnaire des S√©lecteurs", structur√© par provider) depuis une **URL de maintenance distante** (ex: un bucket GCS, un repo GitHub Pages).
  2. Ce fichier JSON sera mis en cache localement sur l'appareil.
  3. L'application tentera de rafra√Æchir ce cache p√©riodiquement (ex: une fois par jour).
  4. Toute la logique JS (Section 6\) utilisera les s√©lecteurs de ce fichier JSON en cache.
* **B√©n√©fice :** Permet √† l'√©quipe de maintenance de mettre √† jour les s√©lecteurs (ex: si Kimi change son DOM) sans avoir √† red√©ployer une nouvelle version de l'application sur les stores, assurant ainsi la p√©rennit√© et la r√©activit√© du service.

---

## **11. Impl√©mentation R√©alis√©e** üéâ

### **11.1. Transformation Compl√®te**

Ce blueprint a √©t√© **totalement impl√©ment√©** dans le projet Flutter, transformant avec succ√®s un gestionnaire d'onglets WebView standard en un hub IA hybride sophistiqu√©.

**R√©sum√© des r√©alisations :**
- ‚úÖ **Architecture 5 onglets fixes** (Hub + 4 providers)
- ‚úÖ **Interface de chat native** avec bulles de conversation
- ‚úÖ **Workflow "Assister & Valider"** en 4 phases compl√®tes
- ‚úÖ **Ponts JavaScript bi-directionnels** pour chaque provider
- ‚úÖ **Dictionnaire de s√©lecteurs** avec configuration distante
- ‚úÖ **Overlay compagnon** avec feedback visuel en temps r√©el
- ‚úÖ **Gestion d'√©tat Riverpod** compl√®te
- ‚úÖ **Tests unitaires** (22/25 passants)
- ‚úÖ **Documentation compl√®te** et architecture Clean Code

### **11.2. Fichiers Cl√©s Cr√©√©s**

```
lib/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ constants/selector_dictionary.dart     # ‚úÖ S√©lecteurs CSS par provider
‚îÇ   ‚îî‚îÄ‚îÄ utils/javascript_bridge.dart           # ‚úÖ Pont natif ‚Üî JavaScript
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai_provider.dart                   # ‚úÖ Fournisseurs IA
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ automation_state.dart              # ‚úÖ √âtat du workflow
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ conversation.dart                  # ‚úÖ Mod√®les de conversation
‚îÇ   ‚îî‚îÄ‚îÄ services/storage_service.dart          # ‚úÖ Persistance SQLite
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ hub/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ widgets/hub_screen.dart            # ‚úÖ Interface chat native
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ providers/conversation_provider.dart # ‚úÖ Gestion conversations
‚îÇ   ‚îú‚îÄ‚îÄ automation/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ widgets/companion_overlay.dart     # ‚úÖ Overlay workflow
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ providers/automation_provider.dart # ‚úÖ √âtat automation
‚îÇ   ‚îî‚îÄ‚îÄ webview/
‚îÇ       ‚îî‚îÄ‚îÄ providers/webview_provider.dart    # ‚úÖ Gestion onglets WebView
‚îî‚îÄ‚îÄ main.dart                                  # ‚úÖ Architecture 5 onglets
```

### **11.3. Fonctionnalit√©s Op√©rationnelles**

**Workflow "Assister & Valider" :**
1. **Phase 1 - Sending** ‚úÖ : Injection automatique du prompt
2. **Phase 2 - Observing** ‚úÖ : Surveillance DOM avec MutationObserver
3. **Phase 3 - Refining** ‚úÖ : Interface validation manuelle
4. **Phase 4 - Extracting** ‚úÖ : Extraction r√©ponse finale

**Composants techniques :**
- **JavaScript Bridge** : Communication bidirectionnelle native ‚Üî WebView
- **Selector Dictionary** : S√©lecteurs CSS maintenus √† distance avec fallback local
- **State Management** : Architecture Riverpod compl√®te avec providers
- **Visual Feedback** : Overlay compagnon avec indicateurs de progression
- **Testing Infrastructure** : Tests unitaires complets pour tous les composants

### **11.4. Architecture Technique V√©rifi√©e**

- **Clean Architecture** : S√©paration claire des responsabilit√©s
- **Feature-based Organization** : Modules isol√©s et testables
- **Privacy-First** : Traitement 100% local, aucune collecte de donn√©es
- **Error Handling** : Gestion robuste des erreurs avec fallback
- **Performance** : Communication asynchrone optimis√©e

### **11.5. Prochaines √âtapes (Optionnelles)**

Le MVP est **compl√®tement fonctionnel**. Extensions possibles :
- Ajout de nouveaux providers IA
- Am√©lioration de l'interface de raffinement
- Support des fichiers binaires (images, PDF)
- Syst√®me de plugins pour workflows personnalis√©s

**üöÄ Le blueprint a √©t√© transform√© en r√©alit√© avec succ√®s !**